class ParticleSwarmOptimization{
    pBestRatio = 1;
    gBestRatio = 1;
    gBest = 0;
    pBest = [];
    w = 0.2;
    iterationValue = 100;
    saturateValue = 0;
    speed = [];
    swarm = [];
    fitnessValues = [];
    fitnessFunctionParams = null;
    isDone = false;
    fitnessFunc =  (value, index, array)=>{};
    constructor(swarm,
                pBestRatio = 1,
                gBestRatio = 1,
                w = 0.2,
                iterationValue = 100,
                saturateValue = 0,
                fitnessFunctionParams = null,
                fitnessFunction) {
        this.swarm = swarm.map((val) => val);
        this.pBestRatio = pBestRatio;
        this.gBestRatio = gBestRatio;
        this.w = w;
        this.iterationValue = iterationValue;
        this.saturateValue = saturateValue;
        //Assign callback fitness function and parameters
        this.fitnessFunc = fitnessFunction;
        this.fitnessFunctionParams = fitnessFunctionParams;

        //Calculate fitness values and check parameters are null
        this.fitnessValues = this.swarm.map(this.fitness.bind(this));

        //Calculate personal Best (Initial pBest current location)
        this.pBest = this.swarm.map((val) => val);
        //Calculate speed on dimension (Initial speeds are 0)
        if (this.swarm[0].constructor === Array) {
            this.gBest = Array.from({length: this.swarm[0].length}, () => 0);
            this.speed = this.swarm.map(() => [0,0]);
        }
        else
        this.speed = this.swarm.map(() => 0);
    }
    async iteration() {
        let iterate = 0;
        this.isDone = false;
        //Iterate while iteration count and not saturated
        while (this.fitnessValues.some(
            (value, index, array, saturate = this.saturateValue) => {
                return value < saturate;
            }) && iterate < this.iterationValue) {
            iterate++;
            //Find global best
            this.gBest = this.swarm[this.fitnessValues.indexOf(Math.max.apply(null, this.fitnessValues))];

            //Calculate particle speeds
            this.swarm.map((value, index) => {
                let pRandom = Math.random();
                let gRandom = Math.random();

                if (this.swarm[0].constructor === Array) {
                    value.map((val, ind, arr) => {
                        this.speed[index][ind] = (this.w * this.speed[index][ind] +
                            this.pBestRatio * pRandom * (this.pBest[index][ind] - val) +
                            this.gBestRatio * gRandom * (this.gBest[ind] - val));
                    });
                } else
                    this.speed[index] = (this.w * this.speed[index] +
                        this.pBestRatio * pRandom * (this.pBest[index] - value) +
                        this.gBestRatio * gRandom * (this.gBest - value));
            });
            //Make movement
            this.swarm.forEach((value, index, array) => {
                if (this.swarm[0].constructor === Array)
                    value.map((val, ind, arr) => {
                        arr[ind] += this.speed[index][ind];
                    });
                else
                    array[index] += this.speed[index];
            });
            //Calculate personal best
            let tempFitnessValues = this.swarm.map(this.fitness.bind(this));
            //Assign personal best
            tempFitnessValues.map((value, index) => {
                if (value > this.fitnessValues[index]) this.pBest[index] = this.swarm[index];
            });
            //Calculate new fitness values
            this.fitnessValues = tempFitnessValues.map((val) => val);
            await this.sleep(33).then(console.log(iterate));
        }
        this.isDone = true;
        return this.gBest;
    }
    fitness(value, index, array) {
        if(this.fitnessValues != null) 
            return this.fitnessFunc(value, index, array, this.fitnessValues);
        else
            return this.fitnessFunc(value, index, array);
    }
    sleep(ms) {
        return new Promise(
            resolve => setTimeout(resolve, ms)
        );
    }
}
module.exports = ParticleSwarmOptimization;