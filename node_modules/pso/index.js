class ParticleSwarmOptimization{
    pBestRatio = 1;
    gBestRatio = 1;
    gBest = 0;
    pBest = [];
    w = 0.2;
    swarmSize = 100;
    iterationValue = 100;
    saturateValue = 0;
    speed = [];
    swarm = [];
    fitnessValues = [];
    fitnessFunctionParams = null;
    fitnessFunc =  ()=>{};
    constructor(swarm,
                pBestRatio = 1,
                gBestRatio = 1,
                w = 0.2,
                swarmSize = 100,
                iterationValue = 100,
                saturateValue = 0,
                fitnessFunctionParams = null,
                fitnessFunction) {
        this.swarm = swarm;
        this.pBestRatio = pBestRatio;
        this.gBestRatio = 1;
        this.w = w;
        this.swarmSize = swarmSize;
        this.iterationValue = iterationValue;
        //Assign callback fitness function and parameters
        this.fitnessFunc = fitnessFunction;
        this.fitnessFunctionParams = fitnessFunctionParams;

        //Calculate fitness values and check parameters are null
        this.fitnessValues = this.swarm.map(this.fitnessFunctionParams == null ?
                                        this.fitnessFunc :
                                        this.fitnessFunc, this.fitnessFunctionParams);

        //Calculate personal Best (Initial pBest current location)
        this.pBest = this.swarm;
        //Calculate speed on dimension (Initial speeds are 0)
        this.speed = this.swarm.map(() => {
            return 0;
        }
        );
    }
    iteration(){
        let iterate = 0;
        //Iterate while iteration count and not saturated
        while(!this.fitnessValues.some(
            (value, index, array, saturate = this.saturateValue) => {
                return value <= saturate;
                }) && iterate < this.iterationValue) {
            iterate++;
            //Find global best
            this.gBest = Math.max.apply(null, this.fitnessValues);

            //Calculate particle speeds
            this.swarm.map((value, index) => {
                let pRandom = Math.random();
                let gRandom = Math.random();
                this.speed[index] = (this.w * this.speed[index] +
                    this.pBestRatio * pRandom * (this.pBest[index] - value) +
                    this.gBestRatio * gRandom * (this.gBest[index] - value));
            });
            //Make movement
            this.swarm.forEach((value, index, array) => {
                array[index] += this.speed[index];
            });
            //Calculate personal best
            let tempFitnessValues = this.swarm.map(this.fitnessFunctionParams == null ?
                this.fitnessFunc :
                this.fitnessFunc, this.fitnessFunctionParams);
            //Assign personal best
            tempFitnessValues.map((value, index) => {
                if (value > this.fitnessValues[index]) this.pBest[index] = this.swarm[index];
            });
            //Calculate new fitness values
            this.fitnessValues = tempFitnessValues;
        }
        return this.gBest;
    }
}
module.exports = ParticleSwarmOptimization;